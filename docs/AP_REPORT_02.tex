
\documentclass[a4paper, oneside, 11pt]{report}
\usepackage{epsfig,pifont,float,multirow,amsmath,amssymb}
\newcommand{\mc}{\multicolumn{1}{c|}}
\newcommand{\mb}{\mathbf}
\newcommand{\mi}{\mathit}
\newcommand{\oa}{\overrightarrow}
\newcommand{\bs}{\boldsymbol}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\usepackage{algorithm}
\usepackage{algorithmic}
\topmargin = 0pt
\voffset = -80pt
\oddsidemargin = 15pt
\textwidth = 425pt
\textheight = 750pt

\begin{document}

\begin{titlepage}
\begin{center}
\rule{12cm}{1mm} \\
\vspace{1cm}
{\large  CMP-6048A Advanced Programming}
\vspace{7.5cm}
\\{\Large Project Report - 15 January 2024}
\vspace{1.5cm}
\\{\LARGE MATBAP: Maths Interpreter software}
\vspace{1.0cm}
\\{\Large Group members: \\ Igor Stepanenko, Lyra Dalton, Liam Farese\ }
\vspace{10.0cm}
\\{\large School of Computing Sciences, University of East Anglia}
\\ \rule{12cm}{0.5mm}
\\ \hspace{8.5cm} {\large Version 2.0}
\end{center}
\end{titlepage}


\setcounter{page}{1}
%\pagenumbering{roman}
%\newpage


\begin{abstract}
% Please replace this section with your own abstract. An abstract is a brief summary (maximum 250 words) of your entire project. It should cover your objectives, your methodologies used, a brief developmental history, your final results, in particular covering the optional tasks, and a discussion and conclusion. You do not cover the literature or background in an abstract nor should you use abbreviations or acronyms. The remainder of this report template has clear chapter titles and we suggest to stick to these although you can organise your material inside each chapter to your own preferences. A guideline in size is approximately 3,500 words (not including abstract, captions and references) but no real limit on figures, tables, diagrams, pseudo-code etc.

This project report discusses the development and implementation of a Maths Interpreter Software, aimed at evaluating and plotting maths expression. The main objective was to create an application capable of evaluating complex maths expression, with focus on performing arithmetic operations, plotting lines and polynomials and assigning variables.

Our methodology included Model-View-ViewModel, Dependency Injection and Service Layer design patterns, and followed best practices such as SOLID principles. The development started with creating core functionality like the F\# interpreter and C\# GUI. As we progressed through the semester, we implemented compulsory features like expression solving, plotting and variable assignment that were outlined in the MoSCoW table. In the end, we managed to complete not just all 'Must' and 'Should' objectives, but also several 'Could' features, such as adding tangents, differentiation, visualising parse tree, finding roots, functions, for-loop, which made our app more versatile.

In conclusion, this project not only met all of it compulsory objectives but also included several optional features. The result is a user-friendly, versatile and robust Maths Interpreter Software that proves the effectiveness of our methodology. The report discusses potential future improvements, such as support for Complex and Rational numbers and Parser optimisation, which would improve software's versatility and performance.


\end{abstract}

\chapter{Introduction}
\label{chap:intro}

\section{Project statement}
This project will be a Maths Interpreter software. It will be used to evaluate expressions, assign variables and plot functions. The software will allow the user to enter expressions using a custom language which is processed by an F\# engine. Additional functionality might include root finding, differentiation and integration. This app will be developed following SOLID principles and best practices through the usage of Model-View-ViewModel and Dependency Injection patterns.

\section{Aims and objectives}
The main aim is to develop Matbap, a maths interpreter software for solving and plotting mathematical expressions. Main objectives include:
\begin{itemize}
    \item Create Lexer, Parser and Evaluator in F\# to process mathematical expressions, equations to plot and support future features.
    \item Develop a Graphical User Interface (GUI) in C\# for user interaction and to handle business logic.
    \item Integrate F\# and C\# components keeping in mind SOLID principles and best practices.
\end{itemize}

\noindent % Start a new paragraph without indentation
They are broken further into subtasks in this MoSCoW table under Appendix \ref{appendix:moscow}.


\chapter{Background}
Today, educational institutions starting from schools and going up to top universities in the world utilise powerful maths software, capable of doing arithmetic and visualising graphs, to aid in their teaching and research. In this chapter, we will acknowledge some of the key software and literature in this field.

The most popular software is 'MATLAB'\cite{Matlab:2023}. It is a mainstream tool in the field of numerical computing, visualisation and programming, that is widely used in academia and professional industry. It offers rich tooling that includes signal and image processing.  

Desmos\cite{Desmos:2023} is another software, commonly used in education to teach students. It offers a graphical calculator with an intuitive user interface and robust plotting functionality to allow for visualisations of complex functions.

When designing Matbap, we consulted different documentations, such as about the Windows Presentation Foundation (WPF)\cite{WPF:2023} provided by Microsoft Learn which offers tutorials on creating desktop user interfaces on Windows using C\#. WPF’s powerful data-bindings are crucial in accepting user's input and displaying the response.

The Dependency Injection (DI) \cite{DI:2023} documentation from Microsoft Learn described the design pattern that produces more testable and modular software. In the context of our application, this pattern allowed for dynamic integration of interfaces like equation evaluator and plotting service within other components, and as a result made our software more maintainable, scalable and testible.

The Model-View-ViewModel (MVVM)\cite{MVVM:2022} documentation from Microsoft Learn describes the architecture, which is primarily used with WPF applications due to its powerful data-binding features. MVVM creates a clear separation of concerns where business logic is decoupled from the UI. This architecture was important in developing our software because it allowed for maintainable and scalable code, which could handle mathematical calculations, user interactions and displaying plots.


\chapter{Development History}\label{Chap:DevHist}

\section{Sprint 0: Setup development infrastructure}
At the very start of this project, we needed to setup and integrate essentials tools that have been critical in streamlining workflow and improving teamwork.

\subsection{Jira Board}
To track our work, we chose Jira\cite{Atlassian:JIRA} - tool for task management and sprint planning, which provided us with visual representation of our project's progress. We setup a Jira Board \ref{ap-jira-link} that helped us create a backlog tickets, that can be assigned to a team member and tracked in To Do, In Progress and Done columns.

\subsection{Visual Studio Project}
Next we configured a Visual Studio solution that could reference a F\# application in a C\# application as a DLL\cite{DLL}.

\subsection{GitHub repository}
We setup a version a control system for our codebase - GitHub repository(link - \ref{github-repo}). This enabled us to collaborate, peer review each others work and keep a history of contributions to the project. A significant objective was to setup a Continuous Integration (CI)\cite{Atlassian:CI} using GitHub Actions\cite{GitHubDocs:Actions} to ensure that our codebase remains bug free through automated testing before any changes are merged to the main branch.

\subsection{Conclusion}
This sprint has laid foundation to our development journey. Setting up tools like Jira, GitHub and Visual Studio not only streamlined our workflow but also enabled us to be an effective and efficient team.

% https://liamfarese.atlassian.net/browse/AP-8
\section{Sprint 1: Basic arithmetic calculations, Basic GUI.}
In our first sprint, we focused on building the foundation of our maths interpreter, like basic arithmetic calculations and basic GUI. Our objective was to develop a software that mathces the spec requirements and is a robust and scalable application, keeping in mind maintainability and testability.

\subsection{Lexer}
We developed a lexer that would tokenise expressions consisting of digits, binary operations, identifiers and functions like sin, cos and tan. One of the challenges we faced was unfamiliarity with F\# and functional programming, especially the recursive nature of this programming paradigm. 

\subsection{Parser}
We developed a parser that would parse and evaluate expressions that followed this basic grammar.
\begin{verbatim}
 <E>    ::= <T> <Eopt>
 <Eopt> ::= + <T> <Eopt> | - <T> <Eopt> | <empty>
 <T>    ::= <NR> <Topt>
 <Topt> ::= * <NR> <Topt> | / <NR> <Topt> | <empty>
 <NR>   ::= <int> | <float> | (E)
\end{verbatim}

\subsection{Basic GUI}
We used WPF\cite{WPF:2023} with C\# to develop a basic GUI, focusing on maintainability, testability, and scalability. App's architecture consists of several design patterns like Model-View-ViewModel\cite{MVVM:2022}, that improves GUI's responsiveness to user interactions and Dependency Injection\cite{DI:2023} for better modularity and easy maintenance. The GUI was a minimalistic interface allowing users to enter expressions and view the answers - see Figure \ref{basicgui}.

\subsection{Testing}
Thorough unit tests were written for both the C\# app and the F\# engine. Table \ref{sprint1-lexer-test} includes unit test for the Lexer. Table \ref{sprint1-parser-test} includes unit tests for the Parser. The table with GUI unit tests can be seen under Appendix \ref{app:test}. The use of the MVVM and Dependency Injection patterns allowed us to to use the Moq\cite{Moq} mocking library to mock Model behaviours in our ViewModel. This allowed us to test code in isolation without relying on behaviour of real dependencies and to have control over what is returned from the mocked methods. As a result our code coverage was above 80\%.

\subsection{Conclusion}
The first sprint laid a solid foundation for our maths interpreter. The lexer and parser were capable of evaluation basic arithmetic expressions and the GUI was providing simple interface for user interaction. Our testing strategy set a ensured that future features were build upon a reliable codebase. 

%https://liamfarese.atlassian.net/browse/AP-30
\section{Sprint 2: Modulo and Power, Correct treatment of integers and floats, Help Menu, Lexer error handling, Link C\# app with F\# engine}

In our second sprint, we focused on improving functionality and user experience of our maths interpreter. Key improvements were support for modulo and power operators, correct handling of integers and floats, better errors in the Lexer and linking our GUI with the interpreter.

\subsection{Lexer}
We updated our lexer with better errors. Now it returns error messages that include the problematic token and its position. This improvement helped us in our debugging processes and provided more clarity to users.

\subsection{Parser}
After a review from the teaching team, we identified a bug. We didn't correctly handle our floats and integers. Previously, integers were cast to floats in order to allow calculation with them. Our fix allowed integers and floats to be handled separately: integer operations would always return integers and the same would happen for floats. The updated BNF reflects this change:
\begin{verbatim}
<E>    ::= <T> <Eopt>
<Eopt> ::= + <T> <Eopt> | - <T> <Eopt> | <empty>
<T>    ::= <NR> <Topt>
<Topt> ::= * <NR> <Topt> | / <NR> <Topt> | <empty>
<NR>   ::= <num> | (E)
<num>  ::= <int> | <float>
\end{verbatim}

Furthermore, we added support for modulo (\%) and power (\textasciicircum) operators. This is reflected in this updated BNF:
\begin{verbatim}
<E>    ::= <T> <Eopt>
<Eopt> ::= + <T> <Eopt> | - <T> <Eopt> | <empty>
<T>    ::= <P> <Topt>
<Topt> ::= * <P> <Topt> | / <P> <Topt> | % <P> <Topt> | <empty>
<P>    ::= <NR> <Popt>
<Popt> ::= ^ <NR> <Popt> | <empty>
<NR>   ::= <num> | (E)
<num>  ::= <int> | <float>
\end{verbatim}


\subsection{Updated GUI}
The GUI was updated with a Help window, that showed all supported tokens. This addition improved user accessibility. The connection of our GUI to our interpreter allowed for real time calculations. The screenshot of updated GUI can be seen in TODO \ref{helpgui}.

\subsection{Testing}
We updated our unit tests to validate new features and fixed bugs. They can be seen under Appendix \ref{app:test}.

\subsection{Conclusion}
Sprint 2 has made good progress in developing our maths interpreter. The introduction of new operators and the correction of behaviour around integer and floats improved our app's versatility and better matched requirements. The lexer's errors and updated GUI improved user experience.


% https://liamfarese.atlassian.net/browse/AP-42
\section{Sprint 3: Unary minus, Assign variables, Functions, Plotting lines and polynomials}
In the third sprint we focused on extending our app’s functionality to support unary minus, variable assignments, and basic plotting functionality. These improvements aimed to increase app’s versatility, aligning with our goal to build a Maths Interpreter.

\subsection{Lexer}
We have updated our Lexer to recognise an assignment operator. The addition was critical to allow variable assignment functionality, allowing users to create and manipulate variables in their expressions. The implementation was to add a ‘=‘ operator to our set of tokens.

\subsection{Parser}
Unary minus was simple, as it could simply be detected as a grammar rule with an associated expression. However, variable assignment was slightly more complicated. The highest level expression in the grammar had to be changed to be optionally either a variable assignment or a normal expression.


\subsection{Evaluator}
To assign and interpret variables, a symbol table had to be used. It is effectively a dictionary, where each unique variable (key) has a single associated value. This symbol table is passed to the evaluation function; any variable assignments are stored in the symbol table, and their value is taken from the symbol table when references to them are made.
A function was created, separate from regular evaluation, to return a list of points for an expression in a given range within a certain step between them. To do this it leveraged the evaluator using a symbol table containing x as a variable, repeating this for every x per step in the given range.

\begin{algorithm}[th]
\caption{ Point calculating function }
\begin{algorithmic}[1]
\STATE Define a starting value (x), an end value, and a step
\STATE Create a list of points
\WHILE {x < end value}
    \STATE Let y = f(x)
    \STATE Add the point (x,y) to the list of points
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\subsection{Updated GUI}
To allow for basic plotting, we introduced a new Plotting Mode in the GUI. User could input equations, define x range and step. As a result of this change, we introduced new plotting ViewModel and View. We decided to use OxyPlot\cite{Oxyplot} - a popular plotting library in C\#, because of its ease of use. The ViewModel was full of code interacting with F\# engine, setting up OxyPlot plot model and generating line series for the function. However, we later realised that this design was flawed due to its scalability limitations and maintainability struggle, which we will fix in the future sprints. You can see new GUI under Appendix \ref{app:gui}.

\subsection{Testing}
Unit tests were added to cover all aspects of new features. These tests ensured correct implementations of unary minus, variable assignment and ViewModel’s interactions with F\# engine and View. These tests are in the table that can be found under Appendix \ref{app:test}.


\subsection{Conclusion}
This sprint has made great progress towards meeting all compulsory objectives tasks we had outlined in our MoSCoW table. Introduction of variable assignment and unary minus laid the foundation for plotting and future advanced features.



% https://liamfarese.atlassian.net/browse/AP-50
\section{Sprint 4: AST Parser and AST Evaluator}
While researching advanced features, we quickly realised we are very limited to what we can do with our F\# engine because it does not create an Abstract Syntax Tree (AST) and as a result we would struggle to add advanced features. In this sprint, we decided to refactor our Parser and Evaluator to construct and evaluate an AST.

\subsection{Parser}
Our strategy was to incrementally build a new parser. We started with integrating simple grammar from our existing BNF. Next we have implemented operators like power, modulo and unary minus. The last addition was variable assignment. This resulted in a fully functional parser that builds an AST of the expression. One of the crucial things we have almost missed was that the requirement for power operations to be right-associative. We were able to catch that using our extensive unit tests framework.
\begin{verbatim}
    type NumType =
        | Int of int
        | Float of float

    type Node =
        | Number of NumType
        | BinaryOperation of string * Node * Node
        | ParenthesisExpression of Node
        | UnaryMinusOperation of string * Node
        | VariableAssignment of string * Node
        | Variable of string
\end{verbatim}
Variable assignment was straightforward to implement as we had already defined the BNF and produced an implementation for the old parser and evaluator, however one improvement over the old version is the inclusion of more robust error messages, the new AST parser checks for an empty right hand side of an assignment ($x = $) and for an assignment without a variable name ($= 2/3$). Additionally, we have moved away from exceptions for error handling used in the old parser in favor for the Result monad which is more idiomatic for the functional programming paradigm.

\subsection{AST Evaluator}
Previously, the F\# engine evaluated at the same time as parsing. This means that, instead of recursive calls returning nodes, they would return the result of calculations. By splitting the evaluator away from the parser, the tree generated by the parser has to be traversed by the evaluator, again using recursive function calls. F\# is well suited for this, particularly with match statements.
One difficulty in doing this was moving the evaluation logic from the old parser to work with the new one - a few new helper functions had to be introduced for this, mostly due to differing return types. The traversal logic was rather simple, as it was very similar to the parser's.

\subsection{Testing}
Our unit tests written for the Parser were extensive to ensure correct AST is generated. They included testing for
\begin{itemize}
    \item correct integer and float nodes are created, 
    \item accurate nodes for simple and combined arithmetic operations, and nested parenthesis,
    \item accurate handling of power, modulo, and unary minus operations, 
    \item variables and variable assignment. 
\end{itemize}
The unit tests for the Evaluator were based on the original tests before AST generation, but with new ones to cover various added features including modulus, exponentiation, unary minus, and variable assignment.
The tests can be seen under Appendix \ref{app:test}.

\subsection{Conclusion}
In this sprint we have made a massive refactor to transition to an AST architecture for parsing and evaluating stages. This not only solved our limitation issue, but also opened the doors to implement several advanced features.

\section{Sprint 5: Visualise parse tree, Multiple plots, Plotted functions table}
During this sprint, we continued to focus on improving our app's functionality. With introduction of the Abstract Syntax Tree Parser we set out to complete several optional objectives, such as visualising the parse tree, enabling users to plot multiple graphs and displaying all plotted function in a user-friendly table.

\subsection{Visualising parse tree}
Introduction of the Abstract Syntax Tree parser resulted in implementation of a converter between F\# and C\# for visualisation. We have introduced an abstract class $ASTNode$ and a converter class $ASTManager$. For the visualisation, we opted for Microsoft Automatic Graph Layout\cite{MSAGL} - a popular library used to display graph data structures, which we have adapted to display our Abstract Syntax Tree. The visualisation provides clarity for developers and users about the underlying parsing process. The resulting GUI can be seen under Appendix \ref{app:gui}.

\subsection{Adding multiple plots, Clearing plot area, Displaying plotted functions, Selecting and Clearing plots}
Anticipating more complex plotting functionality like adding tangents, we decided to extend our plotting mode to support adding multiple plots. The key change was refactoring our PlotViewModel to store a single instance of the OxyPlot's plot model. We also added a button to clear the plotting area to improve interface's flexibility and user experience. 

The ability to add multiple plots to the plot area introduced potential user confusion. To solve this issue, we implemented a feature to display all plotted functions, allowing users to select a plot to perform an operation like adding a tangent or showing area under the curve. This features involved storing all plots in a map, that could be displayed in the GUI using WPF's powerful data template and data binding features. The resulted GUI can be seen under Appendix \ref{app:gui}.

\subsection{Testing}
In this sprint, we concentrated our testing on new functionalities like $ASTManager$ class correctly converting F\# nodes to C\# nodes. The tests can be found under Appendix \ref{app:test}.

\subsection{Conclusion}
In this sprint we have added an advanced feature like Visualising the parse tree and laid a solid foundation for future work by enabling plotting multiple functions.

\section{Sprint 6: Differentiation, Adding tangents}
In this sprint, we tackled maths toolbox objective, specifically Differentiation. This addition aimed at expanding our app's functionality by allowing us to implement features that use differentiation.

\subsection{Differentiation}
From our first year maths module we recalled simple differentiation, but needed guidance on how to handle more complex expression. We started researching on how to perform differentiation on expressions with binary operations, trigonometric and logarithmic functions. Using Derivative rules\cite{Derivatives} we outlined Sum, Difference, Product, Quotient, Power and Chain rules. The resulting algorithm would recursively traverse the Abstract Syntax Tree and apply appropriate rule on the node it encountered. It can be seen under Appendix \ref{app:algorithms}. An important decision was whether to allow non-constant powers. We decided against it, because supporting them would introduce a level of complexity we wasn't sure we would have time to implement and test properly.

\subsection{Adding tangents and refactoring GUI architecture}
With the addition of differentiation we were able to implement functionality to add a tangent to a graph, because the derivative tells us a slope of any function. This feature highlighted the scalability issue as all the interaction code with F\# engine and OxyPlot's plot model was in the $PlotViewModel$, which was complicating adding anything new to it. Our solution was to introduce a variation of a Service Layer design pattern \cite{ServiceLayer:Wiki}. It involved separating logic into tangent and OxyPlot plot model managers and a plotting service - an API that utilises several managers to provide some functionality for the consumer. This is discussed in more depth in Chapter \ref{code-arch}. This refactor improved code modularity and testability by separating concerns, and allowing for easier addition of new features like Tangents. Reworked GUI can be seen under Appendix \ref{app:gui}.

\subsection{Testing}
During this sprint, our unit tests focused on ensuring our differentiation function was producing a correct Abstract Syntax Tree. They included a unit test for each derivative rule. In our GUI, our unit tests had to be expanded to cover new abstractions and interactions, but thanks to Dependency Injection pattern and mocking, we were able to achieve this smoothly. They can be seen under Appendix \ref{app:test}. 

After adding several new features, it became hard to manually test our apps functionality. Solution involved implementing functional tests that would simulate user behaviour and assert answer returned/displayed. We would run them in our GitHub Actions CI to avoid trouble of manually executing the shell command. They can be seen under Appendix \ref{app:test}.

\subsection{Conclusion}
This sprint was a significant improvement in our app's mathematical and architectural sides. The addition of differentiation and tangents improved app's functionality and provided a valuable lesson in software architecture. These features have set the course for future additions and refactors.


\section{Sprint 7: For Loop with plot function and Root finding}

\subsection{Updated C\# app}
The introduction of the For-Loop with plot function presented an architectural challenge, because it required communication between two ViewModels: $ExpressionViewModel$ and $PlotViewModel$. In the Model-View-ViewModel (MVVM) pattern, it is bad practice to tightly couple two ViewModels together. Our solution involved implementing a messaging system between them. The $ExpressionViewModel$ now sends a message if the user enters a for-loop with plot function. This message carries necessary data avoiding direct interaction between the ViewModels, following MVVM best practices. The $PlotViewModel$ subscribes to these messages and handles them accordingly using the $PlottingSerivce$. This approach maintained the modularity and scalability of our application.

To support finding roots, we have added a new $RootFinder$ service that would evaluate expressions, find roots, validate user input and return the response back to the user. On the GUI side we added a Find Roots, x-minimum and x-maximum buttons. The updated GUI can be seen under Appendix \ref{app:gui}.

\subsection{Root finding}
Root finding was implemented based on the F\# engine's previous point plotting function. To find roots, it first generates the points within a given range. Then, it looks for pairs of adjacent points where one one's y is negative and the other's y is positive. Assuming the function is continuous between these, it uses the bisection method to iterate and find a value of x where y is 0. However, it has a few downsides:
\begin{itemize}
    \item By assuming the function is continuous, it can find false roots. For example, in 1/x, it falsely claims a root at approximately x = 0, where it is actually undefined.
    \item The step size of the points generated is hard-coded, meaning many points are skipped in rapidly changing functions such as sin(1/x). The decision was made to simplify user input, however it could be a possible improvement to allow the user to specify it, or to make it adaptive based on the inputted function.
    \item Floating point accuracy is a big issue. It is hard-coded to accept a point as a root if it's y is accurate to 0 within 10 decimal places, but for some functions it is difficult to even find such a point, so many iterations are necessary. However for most functions it is relatively accurate to the root, within a few decimal places.
\end{itemize}

\begin{algorithm}[th]
\caption{ Root finding algorithm }
\begin{algorithmic}[1]
\STATE Compute a list of points for y=f(x) in the given range
\FOR {each point after the first}
    \IF {its y value is positive/negative, and the previous point's y value is the opposite sign}
        \STATE Find the root of f(x) between the two points' x values, using the bisection method
    \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[th]
\caption{ The bisection method }
\begin{algorithmic}[1]
\STATE Define two values of x near the root where f(x) is positive for one and negative for the other
\STATE Set a limit for the number of iterations
\WHILE {within the iteration limit}
	\STATE Let m be the midpoint between the two values of x
    \STATE Compute f(m) - this is the new estimate of the root
    \IF {f(m) is zero}
        \STATE Break the while loop: root has been found at x = m
	\ELSIF {f(m) is positive}
        \STATE Define m as the new positive x
	\ELSIF {f(m) is negative}
        \STATE Define m as the new negative x
    \ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\subsection{Iteration}
Iteration was a feature we ran into trouble implementing with our joint parser and evaluator, we could not properly inspect the structure of the loop or the expression to be iterated as parsing and evaluation was done simultaneously as we went . Once our engine was refactored to construct an AST, implementing a robust for-loop became a lot simpler, allowing us to assign a variable within the for-loop declaration and use this variable within the loop block to generate points to be plotted. Our initial for-loop implementation allowed for the line $2x+1$ to be plotted between $x = 1$ and $x = 10$ programmtically the following way:

\begin{verbatim}
    for x in range(1,10):
        2*x + 1
\end{verbatim}

However, we ran into issues testing negative values defined in the range such as:

\begin{verbatim}
    for x in range(-10,10):
        2*x + 1
\end{verbatim}

This was due to the initial BNF for our for-loop taking int values as parameters, not taking into account that $-10$ is infact a unary minus operations between $-$ and $10$ and not just an $<int>$.

\begin{verbatim}
    // ForLoop ::= "for" <varID> "in" "range(<int>,<int>)" ":" <E>
    //           | "for" <varID> "in" "range(<int>,<int>,<float>)" ":" <E>
\end{verbatim}



We updated our BNF to become more robust, enabling expressions to be passed as parameters to range() instead of only $<int>$, allowing for negative values

\begin{verbatim}
    // ForLoop ::= "for" <varID> "in" "range(<E>,<E>)" ":" <E>
    //           | "for" <varID> "in" "range(<E>,<E>,<float>)" ":" <E>
\end{verbatim}

\subsection{Function Evaluation}

Now that plotting was possible programmatically, we wanted to re-implement function evaluation from our old combined parser and evaluator in order to plot lines such as $sin(x)$. The initial step was updating the lexer to recognise reserved keywords such as $sin$, $cos$, $tan$ using a map.

\begin{verbatim}
    let private keywords = Map.empty.Add("sin", Sin)
                                    .Add("cos", Cos)
                                    .Add("tan", Tan)
                                    .Add("log", Log)
                                    .Add("exp", Exp)
                                    .Add("for", For)
                                    .Add("in", In)
                                    .Add("range", Range)
\end{verbatim}

during lexing, if one of the strings in this map was encountered, it would replace it with the corresponding token. These tokens were then used to parse and evaluate function calls using the following BNF:

\begin{verbatim}
    // <NR>   ::= <num> | (E) | <func-call>
    // <num>  ::= <int> | <float> | <varVal>

    // <func-call> ::= <func-name>(<E>)
    // <func-name> ::= sin | cos | tan | log
\end{verbatim}

Since the parameters of the for-loop declaration were lexed and parsed, functions were also valid as parameters to a for-loop, such as:

\begin{verbatim}
    for x in range(-cos(1),cos(1), 0.01): 
        sin(x)
\end{verbatim}

\subsection{Testing}
Due to many processes going on under the hood of a for-loop, we ensured that error messages were comprehensive and pointed to as close to the source of the issue as possible, to verify this we included tests that covered every way a for-loop declaration could fail, as well as testing function calls within for-loops.

Regarding function calls, we made sure to test that nested function calls were supported, as well as complex expressions being passed inside functions.

\subsection{Conclusion}
This sprint introduced two significant new features: programmatic plotting through iteration, without the need of using a separate GUI window. It also introduced function evaluation, empowering users with the ability to plot function waves such as sine and cosine with ease. Furthermore, it has expanded our maths toolbox to include root finding.

\section{Sprint 9: Visualise and calculate area under the curve, Visualise and Clear Symbol Table}
This final sprint has improved versatility of our app even further. We have added support for visualising and calculating areas under the curve, using Trapezium Rule, and visualisation and clearing of the SymbolTable.

\subsection{Calculating area under the curve}
While researching how to calculate the area under the curve, we discovered we could find the primitive function first and then apply the limits or simply approximate it instead by using a numerical method such as Newton-Cotes of which the most basic form is the trapezium rule. We opted for the latter option, because, unlike Differentiation, Integration doesn't have rules that we can modify our Abstract Syntax Tree (AST) with. This adds extra complexity to the integration algorithm, which we didn't have time for. 

The trapezium rule works by breaking down the area under the curve into trapeziums and then calculating the sum of the areas of these trapeziums. Below is the pseudocode for it:

\begin{algorithm}
\begin{algorithmic}[1]
\caption{Trapezium rule}
\label{algorithm-trapezium-rule}
\STATE f - A function of the curve
\STATE min - Lower limit of integration
\STATE max - Upper limit of integration
\STATE step - Step
\STATE $trapezoidWidth \gets$ ($max - min$)/$step$
\STATE $totalArea \gets 0$
\STATE $currentX \gets min$ 
\WHILE{$currentX \leq max$}
    \STATE $trapeziumArea \gets 0.5 * (f(x) + f(x + trapezoidWidth)) * trapezoidWidth$
    \STATE $totalArea = totalArea + trapeziumArea$
    \STATE $currentX = currentX + trapezoidWidth$
\ENDWHILE
\end{algorithmic}
\end{algorithm}

There are limitations for this algorithm, for example it is not accurate for very non-linear functions, because the rule approximates the area under the curve using straight lines, which may not fit well with curves with high curvature.

\subsection{Displaying area under the curve}
 Each trapezium has 4 vertices, which are calculated as follows, going clockwise starting from the bottom left corner.
\begin{verbatim}
    ( currentX, 0.0 )
    ( currentX, f(currentX) )
    ( currentX + trapezoidWidth, f(currentX + trapezoidWidth) )
    ( currentX + trapezoidWidth, 0.0 )
\end{verbatim}

Our F\# engine would send these vertices, along with the area to the GUI. They would be handled by the $IntegrationService$ to get a line series for each trapezium and plot it using OxyPlot, resulting in this:

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{Area under the curve.png}
\caption{Area under the curve in the GUI}
\label{basicgui}
\end{center}
\end{figure}

\subsection{Visualise and Clear Symbol table}
To help users keep track of variable assignments and allow to clear the symbol table, we decided to visualise it. Given that we already had a $SymbolTable$ and $SymbolTableManager$ classes, it only took a couple of functions to provide this functionality to the view model. The resulting GUI would include the following Symbol Table:

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{SymbolTableGUIElement.png}
\caption{Symbol table GUI element}
\label{basicgui}
\end{center}
\end{figure}

\subsection{Testing}
Our testing approach for this sprint remained unchanged. We tested the integration module in F\# by asserting correct areas and vertices are calculated for input expressions. They can be seen under Appendix \ref{app:test}.

For our GUI, we developed unit tests to assert correct behaviour of all new functions. Additionally, we created a functional test to validate system's end-to-end functionality regarding showing areas under the curve. For the symbol table, we have added extra assertions to the existing functional test. They can be seen under Appendix \ref{app:test}.

\subsection{Conclusion}
This sprint was an improvement for our maths toolbox and user-experience. The addition of visualising areas under the curve made our app more versatile and the addition of the SymbolTable visualisation made our app more user-friendly.

\chapter{Final deliverable}\label{Impl}
\section{Final BNF}

\begin{verbatim}
    ForLoop ::= "for" <varID> "in" "range(<E>,<E>)" ":" <E>
               | "for" <varID> "in" "range(<E>,<E>,<float>)" ":" <E>
    <varA> ::= <varID> = <E>
    <E>    ::= <T> <Eopt>
    <Eopt> ::= + <T> <Eopt> | - <T> <Eopt> | <empty>
    <T>    ::= <P> <Topt>
    <Topt> ::= * <P> <Topt> | / <P> <Topt> | % <P> <Topt> | <empty>
    <P>    ::= <NR> <Popt>
    <Popt> ::= ^ <NR> <Popt> | <empty>
    <NR>   ::= <num> | (E) | <func-call>
    <num>  ::= <int> | <float> | <varVal>

    <func-call> ::= <func-name>(<E>)
    <func-name> ::= sin | cos | tan | log

    varVal is fetched from symbol table using varID
\end{verbatim}
    

\section{Final GUI}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.4]{FinalGUI.png}
\caption{Final GUI}
\label{basicgui}
\end{center}
\end{figure}

\section{Code architecture}
\label{code-arch}
The final architecture of Matbap follows the Model-View-ViewModel (MVVM) design pattern, with addition of Dependency Injection (DI), Separation of Concerns and other best practices. This approach helps with maintainability, testability and scalability of our application.

\subsection{F\# Engine and Wrappers}
Our F\# mathematical engine is a critical component of our architecture, that provides functionality for interpreting expressions, finding coordinates for plots and others. We have developed interfaces within it to integrate with our C\# application. We used DI to inject these interfaces into F\# Wrappers, which act as adapters enabling our Services and Managers to use the engine.


\subsection{Model}
Model layer consists of entities such as $Expression$, which encapsulates the mathematical expression, that our software handles. Each entity has a manager, like an $ExpressionManager$ that handles Differentiation or Creating an expression. There are also services, such as $ExpressionEvaluationService$, that highlight separation of concerns by handling interactions between several Managers, Services and F\# Wrappers. DI is used here to decouple Services from its dependencies like Managers and Wrappers, ensuring modularity and testability. Services act as APIs for the consumer, such as a ViewModel. They encapsulate complex operations like evaluating expressions and remain decoupled from other layers.

\subsection{ViewModel}
ViewModel's purpose is to link our user interface with the Model layer. It interacts with Services like $ExpressionEvalutingService$, that communicates with Managers and Wrappers. DI is used here to ensure code modularity and testability.

\subsection{UML Diagrams}
Links to our architecture UML class and sequence diagrams can be found under 
Appendix \ref{app:links}.

By using MVVM, Service Layer and DI patterns, following SOLID principles we created an architecture, that is scalable, maintainable and adaptable in the long run.

\section{Testing}
Our testing approach followed best practices in the software engineering industry to ensure reliability of our system. We developed unit tests, which were important in ensuring correct implementation of every function. The use of Dependency Injection helped, because it allowed us to use Mock objects to simulate various scenarios of the dependencies. As a result, we were able to identify bugs and solve them quickly.

In addition to unit tests, we implemented functional tests. They verified end-to-end  functionality of our app, from user's button click to the computations in the F\# engine and to presentation of the response in the GUI. This approach was critical in validating, that integration of new features or a refactor didn't break existing functionality.

The link to the test files can be found under Appendix \ref{app:links}.

\chapter{Discussion, conclusion and future work}

In this final chapter, we will discuss our accomplishments and reflect on the objectives that were outlined in the MoSCoW table under Appendix \ref{appendix:moscow}. We have achieved all of the 'Must' and 'Should', including solving expressions, assigning variables, plotting lines and polynomials, user-friendly GUI, AST parser, visualising parse tree, functions and multiple plots. Furthermore, our team developed several of the 'Could' features, like Differentiation, Adding Tangents, Root finding, For-Loop and Visualsing and calcualting area under the curve. 

Given the project's complexity, the timeframe and the team size, our decision to focus on these features proved to be right in order to achieve the best results.

In the future, we would like Matbap to include support for Rational and Complex numbers. We expect to review our architecture, particularly refactoring visualising AST into its own service. This would improve modularity and testability of our software. Additionally, we will be refactoring our Parser to be more efficient. The implementation of twin functions for our existing F\# functions to accept the AST directly, rather than a string, would save computational costs of converting the AST between F\# and C\#. Another improvement will be the implementation of simplification algorithm for ASTs produced by differentiation, simplifying expression where terms, for example, are multiplied by 0 or 1.

These future improvements reflect our commitment to make Matbap into a more versatile tool. Through continuous iterations and improvements we aim to make it accessible to anyone, regardless of their knowledge of mathematics.

\bibliographystyle{apalike}
\raggedright
\bibliography{References}


\appendix
\chapter{Contributions}


\chapter{Aims and objectives}
\section{MoSCoW table}
\label{appendix:moscow}
\begin{table}[h]
\caption{MoSCoW}
\resizebox{\textwidth}{!}{%
\begin{center}
\begin{tabular}{|p{1in}|p{2in}|p{2.5in}|} \hline
Priority & Task & Comments \\ \hline \hline
\multirow{3}{1in}{Must}
& Solve arithmetic expressions & Works with ints and floats, processing is left-associative, BODMAS/BIDMAS rules apply \\ \cline{2-3}
& Have basic GUI & Input textbox, output textbox and help functionality \\ \cline{2-3}
& Have variable assignment & Assignment token, Grammar change, Stored in a symbol table \\ \cline{2-3}
& Be tested & Unit and functionally tested \\ \cline{2-3}
& Have basic plotting & Plotting area in GUI window to visualise mathematical functions: lines and polynomials \\ \hline \hline
\multirow{3}{1in}{Should}
& AST Parser & Parser constructs an Abstract Syntax Tree \\ \cline{2-3}
& Functions & Works with built-in functions such as cos, sin, tan, exp, log  \\ \cline{2-3}
& AST Visualisation & Visualise the parse tree  \\ \cline{2-3}
& Multiple plots & User can plot multiple equations and clear the plotting area \\ \hline \hline
\multirow{3}{1in}{Could}
& For loops with plot function & Entering for-loop with plot function will plot it \\ \cline{2-3}
& Differentiation & Can differentiate polynomials \\ \cline{2-3}
& Root finding & Can find roots of polynomials \\ \cline{2-3}
& Integration & Can integrate polynomials \\ \cline{2-3}
& Adding tangents & Can add tangents to plots \\ \cline{2-3}
& Visualising and calculating the area under the curve & Can visualise area under cure and it's area \\ \cline{2-3}
& Rational equations plotting & Plot equations that produce more than 1 line \\ \hline \hline
\multirow{3}{1in}{Will not}
& Rational numbers & \\ \cline{2-3}
& Conditionals & If statements \\ \cline{2-3}
& Complex numbers & \\ \cline{2-3}
& Compiler & Too much work to implement a compiler in a given timeframe \\ \cline{2-3}
& Static typing & Requires a very strong typing system in place which is too hard to implement in a given timeframe \\ \hline
\end{tabular}
\label{Table1}
\end{center}
}
\end{table}

\chapter{Testing}
\label{app:test}

\section{F\# engine unit testing}

\begin{table}[h]
\caption{Sprint 1, Lexer unit tests}
\label{sprint1-lexer-test}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Expression}        & \textbf{Pass/Fail} & \textbf{Comment}                      \\ \hline
1a+12                      & Pass               & Tokenises variable, int and operation \\ \hline
33.3/(12 + 3.5a)           & Pass               & Float/Int distinct tokenisation       \\ \hline
sin(43)/cos(1.5) * tan(34) & Pass               & Function tokenisation                 \\ \hline
4 \% 2                     & Pass               & Modulus tokenisation                  \\ \hline
4\textasciicircum{}3       & Pass               & Power tokenisation                    \\ \hline
1. + 43                    & Pass               & Lexer error                           \\ \hline
1.4.2                      & Pass               & Lexer error                           \\ \hline
1\&                        & Pass               & Lexer error                           \\ \hline
\end{tabular}
\end{table}

\begin{table}[h]
\caption{Sprint 1, Parser unit tests}
\label{sprint1-parser-test}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Expression} & \textbf{Pass/Fail} & \textbf{Comment}                                                                     \\ \hline
2+10                & Pass               & Parses and evaluates basic addition                                                  \\ \hline
7-3                 & Pass               & Parses and evaluates basic subtraction                                               \\ \hline
5*7                 & Pass               & \begin{tabular}[c]{@{}l@{}}Parses and evaluates basic \\ multiplication\end{tabular} \\ \hline
12/8                & Pass               & \begin{tabular}[c]{@{}l@{}}Parses and evaluates basic \\ division\end{tabular}       \\ \hline
5*2.3               & Pass               & Parses and evaluates integers with floats                                            \\ \hline
13.56-6+14*20.1     & Pass               & Order of operations                                                                  \\ \hline
5-2.5/(6.0+6.5)+1   & Pass               & Order of operations using brackets                                                   \\ \hline
1\&                 & Pass               & Operators without an operand between                                                 \\ \hline
6+-2                & Pass               & Operators without an operand between                                                 \\ \hline
5/                  & Pass               & Operator without an operand following                                                \\ \hline
*                   & Pass               & Operator with no operands at all                                                     \\ \hline
(()                 & Pass               & Opening a bracket without closing it                                                 \\ \hline
())                 & Pass               & Closing a bracket without having opened a matching one                               \\ \hline
1/0                 & Pass               & Division by 0                                                                        \\ \hline
\end{tabular}
\end{table}

\begin{table}[h]
\caption{Sprint 3, plotting tests}
\label{sprint3-plotting-test}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Expression} & \textbf{Pass/Fail} & \textbf{Comment}                                                                     \\ \hline
2*x+6               & Pass               & Basic linear equation                                                                \\ \hline
x/2                 & Pass               & Linear equation with smaller gradient                                                \\ \hline
(x\^{}2)+(4*x)+4    & Pass               & Basic polynomial                                                                     \\ \hline
x\^{}3+x\^{}2       & Pass               & Third degree polynomial                                                             \\ \hline
2-x\^{}2            & Pass               & Polynomial with negative term                                                       \\ \hline
y=x+2               & Pass               & Cannot assign variables in plot mode                                                \\ \hline
\end{tabular}
\end{table}

\newpage

\begin{table}[h]
\caption{Sprint 4, AST evaluator unit tests}
\label{sprint4-ast-evaluator-test}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Expression} & \textbf{Pass/Fail} & \textbf{Comment}                                                                     \\ \hline
2+10                & Pass               & Evaluates basic addition                                                             \\ \hline
7-3                 & Pass               & Evaluates basic subtraction                                                          \\ \hline
5*7                 & Pass               & Evaluates basic multiplication                                                       \\ \hline
12/8                & Pass               & Evaluates basic division                                                             \\ \hline
5*2.3               & Pass               & Parses and evaluates integers with floats                                            \\ \hline
13.56-6+14*20.1     & Pass               & Order of operations                                                                  \\ \hline
5-2.5/(6.0+6.5)+1   & Pass               & Order of operations using brackets                                                   \\ \hline
8/-2                & Pass               & Unary minus                                                                          \\ \hline
-(6+11)             & Pass               & Unary minus with brackets                                                            \\ \hline
25\^{}0.5           & Pass               & Exponentiation                                                                       \\ \hline
2*3.0\^{}2          & Pass               & Order of operations with exponent                                                    \\ \hline
763\%129\%20        & Pass               & Modulus                                                                              \\ \hline
x=5.5+2             & Pass               & Variable assignment                                                                  \\ \hline
1\&                 & Pass               & Operators without an operand between                                                 \\ \hline
5/                  & Pass               & Operator without an operand following                                                \\ \hline
*                   & Pass               & Operator with no operands at all                                                     \\ \hline
(()                 & Pass               & Opening a bracket without closing it                                                 \\ \hline
())                 & Pass               & Closing a bracket without having opened a matching one                               \\ \hline
1/0                 & Pass               & Division by 0                                                                        \\ \hline
\end{tabular}
\end{table}

\newpage

\begin{table}[h]
\caption{Sprint 5, Differentiation Unit test}
\label{sprint5-differentiation-unit-test}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Expression}       & \textbf{Pass/Fail} & \textbf{Comment}                         \\ \hline
5                         & Pass               & Testing number differentiation           \\ \hline
x                         & Pass               & Testing variable differentiation         \\ \hline
x+y                       & Pass               & Testing polynomial differentiation       \\ \hline
x*y                       & Pass               & Testing product rule                     \\ \hline
x/y                       & Pass               & Testing quotient rule                    \\ \hline
x\textasciicircum{}2      & Pass               & Testing power rule                       \\ \hline
sin(cos(x))               & Pass               & Testing chain rule                       \\ \hline
sin(x\textasciicircum{}2) & Pass               & Testing polynomial with chain rule       \\ \hline
sin(cos(log(x)))          & Pass               & Testing chain rule with nested functions \\ \hline
1@1                       & Pass               & Test error: unsupported operation type   \\ \hline
x=1                       & Pass               & Test error: unsupported node type        \\ \hline
x\textasciicircum{}(1+2)  & Pass               & Test error: non-constant power           \\ \hline
ln(x)                     & Pass               & Test error: unsupported function         \\ \hline
\end{tabular}
\end{table}

\begin{table}[h]
\caption{Sprint 7, root finding unit tests}
\label{sprint7-root-unit-test}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Expression} & \textbf{Pass/Fail} & \textbf{Comment}                                                                     \\ \hline
3*x+2                 & Pass               & Basic linear equation                                                                \\ \hline
x\^{}2+3              & Pass               & Basic polynomial                                                                     \\ \hline
(6*x\^{}2)-3.  2      & Pass               & More complex polynomial                                                             \\ \hline
(x\^{}3)+(3*x\^{}2)-2 & Pass               & Polynomial with three roots                                                         \\ \hline
sin(x)                & Pass               & Trigonometric function                                                              \\ \hline
sin(1/x)              & Fail               & Rapidly changing function - not accurate enough                                     \\ \hline
\end{tabular}
\end{table}

\begin{table}[h]
\caption{Sprint 7, Iteration and Function Evaluation}
\label{sprint8-Iteration-and-Function-unit-test}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\textbf{Expression}              & \textbf{Pass/Fail} & \textbf{Comment}                                           \\ \hline
tan(7/2)                         &Pass                &Testing correct function parsing                            \\ \hline
for x in range(1,5): 2*x + 1     &Pass                &Testing for loop returns a list of points                   \\ \hline
for x in range(0,1): sin(x)      &Pass                &Testing for loop with a function call                          \\ \hline
for x in range(-1,1): sin(x)     &Pass                &Testing for loop with negative values                       \\ \hline
for(1,10) : sin(x)               &Pass                &Test error: Incorrect for-loop declaration                  \\ \hline
for x in range(1,10, 4 : sin(x)  &Pass                &Test error: Incorrect for-loop declaration                  \\ \hline
exp(2                            &Pass                &Test error: Missing closing bracket on function call        \\ \hline
2xx                              &Pass                &Test error: Unable to parse token at end of expression: xx  \\ \hline
for in range(/,10): 2*x          &Pass                &Test error: Error parsing xMin value in range               \\ \hline
for in range(1,*): 2*x           &Pass                &Test error: Error parsing xMax value in range               \\ \hline
\end{tabular}
}
\end{table}


\begin{table}[h]
\caption{Sprint 8, Integration Unit test}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Expression}  & \textbf{Pass/Fail} & \textbf{Comment}                                                            \\ \hline
x                    & Pass               & Testing y=x, in the interval {[}0, 2{]} with a step of 1                    \\ \hline
x\textasciicircum{}2 & Pass               & Testing y=x\textasciicircum{}2, in the interval {[}0, 2{]} with a step of 1 \\ \hline
\end{tabular}
\end{table}

\newpage
\section{C\# GUI unit  and functional testing}

\begin{table}[H]
\caption{C\# app unit tests}
\label{test:sharpapp}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\textbf{Test name}                                                                   & \textbf{Pass/Fail} & \textbf{Comment}                                         \\ \hline
Test PlotManager CreatePlot Success                                                  & Pass               & Test plot creation in plot manager                       \\ \hline
Test PlotManager GetLineSeriesForPlot Success                                        & Pass               & Test that plot manager gets the line series from points. \\ \hline
Test PlotManager GetLineSeriesForPlot Error                                          & Pass               & Test plot manager errors when getting line series.       \\ \hline
Test\_ExpressionManager\_CreateExpression                                            & Pass               & Test expression manager creates expression.              \\ \hline
Test\_ExpressionManager\_DifferentiateSuccess                                        & Pass               & Test expression manager differentiates successfuly       \\ \hline
Test\_ExpressionManager\_DifferentiateError                                          & Pass               & Test expression manager differentiate errors             \\ \hline
Test\_OxyPlotModelManager\_AddSeriesToPlotModel                                      & Pass               & Test OxyPlot manager adds series to the plot model       \\ \hline
Test\_OxyPlotModelManager\_SetupAxisOnPlotModel                                      & Pass               & Test OxyPlot manager sets up axis                        \\ \hline
Test\_OxyPlotModelManager\_ClearPlotModel                                            & Pass               & Test OxyPlot creates a plot model                        \\ \hline
Test\_PlotManager\_CreatePlot\_Success                                               & Pass               & Test Plot manager creates a plot successfuly             \\ \hline
Test\_PlotManager\_GetLineSeriesForPlot\_Success                                     & Pass               & Test Plot manager gets line series for a plot            \\ \hline
Test\_PlotManager\_GetLineSeriesForPlot\_Error                                       & Pass               & Test Plot manager gets line series for a plot with error \\ \hline
ASTManager\_Convert\_\textless{}WhateverNode\textgreater{}\_CreatesCorrectCSharpNode & Pass               & Test AST manager creates a correct C\# node              \\ \hline
ASTManager\_Convert\_ASTtoGraph                                                      & Pass               & Test AST manager converts AST to graph                   \\ \hline
Test\_SymbolTableManager\_GetSymbolTable                                             & Pass               & Test symbol table manager gets a symbol table            \\ \hline
Test\_SymbolTableManager\_UpdateSymbolTable                                          & Pass               & Test symbol table manager updates a table                \\ \hline
Test\_TangentManager\_CreateTangent\_Sucess                                          & Pass               & Test tangent manager creates a tangent                   \\ \hline
Test\_TangentManager\_CreateTangent\_Error                                           & Pass               & Test tangent manager creates a tangent error             \\ \hline
Test\_TangentManager\_GetTangentLineSeries\_Success                                  & Pass               & Test tangent manager gets a line series                  \\ \hline
ASTNodeModel\_Test\textless{}WhateverNode\textgreater{}\_ToString                    & Pass               & Test C\# AST node to string                              \\ \hline
Test\_Expression\_Create                                                             & Pass               & Test expression creation                                 \\ \hline
Test\_FSharpASTGetterWrapper\_GetAST\_HappyPath                                      & Pass               & Test wrapper for F\# GetAst call                         \\ \hline
Test\_FSharpDifferentiatorWrapper\_DifferetiateSuccess                               & Pass               & Test wrapper for F\# Differentiate call                  \\ \hline
Test\_FSharpDifferentiatorWrapper\_DifferetiateError                                 & Pass               & Test wrapper for F\# Differentiate call error            \\ \hline
Test\_FSharpExpressionEvaluatiorWrapper\_Evaluate\_EvaluatesSuccessfully             & Pass               & Test wrapper for F\# Evaluate call                       \\ \hline
Test\_FSharpExpressionEvaluatiorWrapper\_Evaluate\_EvaluatesError                    & Pass               & Test wrapper for F\# Evaluate call error                 \\ \hline
Test\_FSharpFindRootsWrapper\_HappyPath                                              & Pass               & Test wrapper for F\# FindRoots call                      \\ \hline
Test\_FSharpFindRootsWrapper\_UnhappyPath                                            & Pass               & Test wrapper for F\# FindRoots call error                \\ \hline
Test\_FSharpFunctionEvaluatiorWrapper\_Evaluate\_EvaluatesSuccessfully               & Pass               & Test wrapper for F\# PlotPoints call                     \\ \hline
Test\_FSharpFunctionEvaluatiorWrapper\_Evaluate\_Error                               & Pass               & Test wrapper for F\# PlotPoints call error               \\ \hline
Test\_FSharpFunctionEvaluatiorWrapper\_EvaluateAtPoint\_Success                      & Pass               & Test wrapper for F\# Evaluate At call                    \\ \hline
Test\_FSharpFunctionEvaluatiorWrapper\_EvaluateAtPoint\_Error                        & Pass               & Test wrapper for F\# Evaluate At call error              \\ \hline
Test\_SymbolTable\_CreateSymbolTable                                                 & Pass               & Test symbol table is created                             \\ \hline
Test\_SymbolTable\_UpdateSymbolTable                                                 & Pass               & Test symbol table is updated                             \\ \hline
Test\_Tangent\_GetTangentEquation                                                    & Pass               & Test getting tangent equation                            \\ \hline
Test\_DifferentiatonService\_DifferentiateHappyPath                                  & Pass               & Test differentiation service differentiate               \\ \hline
Test\_DifferentiationService\_DifferentiateError                                     & Pass               & Test differentiation service differentiate error         \\ \hline
Test\_DifferentiationService\_ValidateError                                          & Pass               & Test differentiation service validate error              \\ \hline
Test\_DifferentiationService\_GetASTError                                            & Pass               & Test differentiation service GetAst errro                \\ \hline
Test\_DifferentiationService\_ConvertASTError                                        & Pass               & Test differentiation service ConvertAst error            \\ \hline
Test\_ExpressionEvaluatingService\_EvaluatesSuccessfuly                              & Pass               & Test evaluating service Evaluate                         \\ \hline
Test\_ExpressionEvaluatingService\_EvaluatesError                                    & Pass               & Test evaluating service Evaluate error                   \\ \hline
Test\_ExpressionEvaluatingService\_VisualiseASTHappy                                 & Pass               & Test evaluating service visualise ast                    \\ \hline
Test\_ExpressionEvaluatingService\_VisualiseASTError                                 & Pass               & Test evaluating service visualise ast error              \\ \hline
Test\_FindRootsService\_HappyPath                                                    & Pass               & Test Find roots service finds roots successfully         \\ \hline
Test\_FindRootsService\_ValidorUnhappyPath                                           & Pass               & Test Find roots service validator error                  \\ \hline
Test\_FindRootsService\_FSharpWrapperUnhappyPath                                     & Pass               & Test Find Roots service F\# wrapper error                \\ \hline
Test\_PlottingService\_CreatePlot\_Success                                           & Pass               & Test Plotting service create plot successfully           \\ \hline
Test\_PlottingService\_CreatePlot\_ValidatorError                                    & Pass               & Test Plotting Service create plot validator error        \\ \hline
Test\_PlottingService\_CreatePlot\_PlotManagerError                                  & Pass               & Test Plotting Service create plot plot manager error     \\ \hline
Test\_PlottingService\_AddTangent\_Success                                           & Pass               & Test Plotting Service adds a tangent successfully        \\ \hline
Test\_PlottingService\_AddTangent\_ValidatorError                                    & Pass               & Test Plotting Service Add tangent validator error        \\ \hline
Test\_PlottingService\_AddTangent\_EvaluatorError                                    & Pass               & Test Plotting Service add tangent evaluator error        \\ \hline
Test\_PlottingService\_CreatePlotFromExpression                                      & Pass               & Test Plotting Service create plot from expression        \\ \hline
Test\_ValidationService\_Validate\textless{}Some\textgreater{}Input                  & Pass               & Test Validation service validates different input        \\ \hline
Test\_ExpressionViewModel\_EvaluateCmd\_ReceiveAnswerFromEvaluator                   & Pass               & Test ViewModel gets an answer from service               \\ \hline
Test\_ExpressionViewModel\_EvaluateCmd\_ReceiveErrorFromEvaluator                    & Pass               & Test ViewModel gets an error from service                \\ \hline
Test\_ExpressionViewModel\_SendsPlotExpressionMessage                                & Pass               & Test ViewModel sends a message                           \\ \hline
Test\_ExpressionViewModel\_DifferentiateCmd\_HappyPath                               & Pass               & Test ViewModel gets an answer from service               \\ \hline
Test\_ExpressionViewModel\_FindRootsCmd\_HappyPath                                   & Pass               & Test ViewModel gets an answer from service               \\ \hline
Test\_ExpressionViewModel\_FindRootsCmd\_UnhappyPath                                 & Pass               & Test ViewModel gets an error from service                \\ \hline
Test\_PlotViewModel\_PlotCmd\_CreatePlot\_Successfully                               & Pass               & Test ViewModel gets an answer from service               \\ \hline
Test\_PlotViewModel\_PlotCmd\_CreatesPlot\_Error                                     & Pass               & Test ViewModel gets an error from service                \\ \hline
Test\_PlotViewModel\_PlotCmd\_CreatesPlot\_Error                                     & Pass               & Test ViewModel gets an error from service                \\ \hline
Test\_PlotViewModel\_AddtangentCmd\_AddTangent\_SelectedPlotNullError                & Pass               & Test ViewModel gets an error adding tangent              \\ \hline
Test\_PlotViewModel\_AddtangentCmd\_AddsTangent\_Sucess                              & Pass               & Test ViewModel gets an answer from service               \\ \hline
Test\_PlotViewModel\_HandlePlotExpressionMessage\_Success                            & Pass               & Test ViewModel handles message                           \\ \hline
\end{tabular}%
}
\end{table}

\begin{table}[H]
\caption{Functional tests}
\label{test:functional}
\resizebox{\textwidth}{!}
{%
\begin{tabular}{|l|l|l|}
\hline
\textbf{Test Name}                       & \textbf{Pass/Fail} & \textbf{Comment}                                                                                           \\ \hline
AddMultipleTangentsTest                  & Pass               & Test to simulate user creating a Plot and adding several Tangents to it.                                   \\ \hline
AddTangentErrorsTest                     & Pass               & Tests to simulate user creating a Plot and adding a Tangent but inputting invalid data.                    \\ \hline
AddTangentTest                           & Pass               & Test to simulate user creating a Plot and adding a Tangent to it.                                          \\ \hline
ClearPlotsTest                           & Pass               & Test to simulate user adding a plot and then clicking the Clear button.                                    \\ \hline
CreateMultiplePlotsTest                  & Pass               & Test to simulate user creating multiple plots.                                                             \\ \hline
CreatePlotErrorsTest                     & Pass               & Tests to simulate entering equation, xmin, xmax, xstep with invalid data.                                  \\ \hline
CreatePlotTest                           & Pass               & Test to simulate user inputing equation, xmin, xmax, xstep and clicking Plot button.                       \\ \hline
DifferentiateExpressionErrorsTest        & Pass               & Test to simulate user entering a math expression and differentiating it errors.                            \\ \hline
DifferentiateExpressionTest              & Pass               & Test to simulate user entering a math expression and differentiating it.                                   \\ \hline
DisplayMultiplePlottedFunctions          & Pass               & Test to simulate user adding 3 plots and GUI displaying their functions in the "Plotted Functions:" panel. \\ \hline
DisplayPlottedFunctionTest               & Pass               & Test to simulate user adding a plot and it displaying its function in the "Plotted Functions" panel.       \\ \hline
EvaluateExpressionTest                   & Pass               & Test to simulate user entering a math expression and getting an answer back.                               \\ \hline
EvaluateExpressionWithVariablesTest      & Pass               & Test to simulate user entering math expression with variables.                                             \\ \hline
EvaluateExpressionWithVariablesErrorTest & Pass               & Test to simulate user entering math expression that causes errors in Lexer and Parser.                     \\ \hline
EvaluateForLoopPlottingFunctionTest      & Pass               & Test to simulate user entering for loop with plot function and it plots in the plot window.                \\ \hline
FindRootsTest                            & Pass               & Simulate user entering an expression and clicking Find roots button. Gets success response or error.       \\ \hline
VisualiseASTTest                         & Fail               & Cannot be tested. Because WPF Windows are not globally accessible, hence we cannot track if it was opened. \\ \hline
\end{tabular}
}
\end{table}


\chapter{GUI}
\label{app:gui}
\section{Basic GUI}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.5]{Basic GUI.png}
\caption{Our first basic GUI}
\label{basicgui}
\end{center}
\end{figure}

\section{GUI With Help window}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.5]{FirstGUIWithHelp.png}
\caption{Help window}
\label{basicgui}
\end{center}
\end{figure}

\section{GUI with plot mode}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.5]{FirstGUIWithPlotModepng.png}
\caption{First GUI with plot mode}
\label{firstGUIWithPlotMode}
\end{center}
\end{figure}

\section{Visualise parse tree GUI}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.5]{VisualuseASTGUI.png}
\caption{AST visualistion}
\label{basicgui}
\end{center}
\end{figure}

\section{GUI with multiple plots, clear and plotted functions table}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.5]{MultiplePlotsGUI.png}
\caption{Multiple plots and plotted functions table}
\label{basicgui}
\end{center}
\end{figure}

\section{Differentiation GUI}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.5]{DifferentiationGUI.png}
\caption{Differentiation GUI}
\label{basicgui}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.5]{AddTangentsGUI.png}
\caption{Adding tangent GUI}
\label{basicgui}
\end{center}
\end{figure}

\section{GUI with Find Roots}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.5]{FindRootsGUI.png}
\caption{Find roots GUI}
\label{basicgui}
\end{center}
\end{figure}

\section{GUI with Visualising and Calculating Area under the curve, and SymbolTable}
\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.4]{LastSprintGUI.png}
\caption{Visualising Area Under The Curve and SymbolTable GUI}
\label{basicgui}
\end{center}
\end{figure}
\chapter{Algorithms}
\label{app:algorithms}

\begin{algorithm}
\begin{algorithmic}[1]
\caption{Recursively differentiate an AST}
\label{algorithm-differentiate}
\STATE An AST node.
\STATE A variable with respect to differentiate to.
\STATE A Lookup Table(LUT) for trigonometric and logarithmic functions.
    \IF {$node$ is a constant}
        \STATE \Return 0
    \ELSIF {$node$ is a variable}
        \STATE \Return 1
    \ELSIF {$node$ is a not variable we differentiate with respect to}
        \STATE \Return 0
    \ELSIF {$node$ is a binary operation}
        \IF {$node$ is addition or subtraction}
            \STATE $u \gets$ {Differentiate}({$node.left$})
            \STATE $v \gets$ {Differentiate}({$node.right$})
            \STATE \RETURN u $\pm$ v
        \ELSIF {$node$ is multiplication}
            \STATE $u \gets$ {Differentiate}({$node.left$})
            \STATE $v \gets$ {Differentiate}({$node.right$})
            \STATE \RETURN u $\times$ $node.right$ + v $\times$ $node.left$ 
        \ELSIF {$node$ is division}
            \STATE $u \gets$ {Differentiate}({$node.left$})
            \STATE $v \gets$ {Differentiate}({$node.right$})
            \STATE \RETURN $(u \times node.right - v \times node.left) / (node.right)^2$
        \ELSIF {$node$ is a power}
            \STATE $u \gets$ {Differentiate}({$node.left$})
            \STATE $v \gets$ {Differentiate}({$node.right$})
            \STATE \RETURN $node.right$ $\times$ $node.base^{node.right-1}$ $\times$ {Differentiate}({$node.base$})
        \ENDIF
    \ELSIF {$node$ is a trigonometric or logarithmic function}
        \STATE $u \gets node.innerNode$
        \STATE $du \gets$ {Differentiate}({$u$})
        \STATE $outerDerivative \gets$ {LUT}({$node.function$})
        \STATE \RETURN $outerDerivative(u) \times du$
    \ENDIF
    
\end{algorithmic}
\end{algorithm}


\chapter{Links}
\label{app:links}
\section{Jira Board}
https://liamfarese.atlassian.net/jira/software/projects/AP/boards/2
\label{ap-jira-link}

\section{GitHub repository}
https://github.com/IgorSteps/matbap
\label{github-repo}

\section{UML diagrams}
https://github.com/IgorSteps/matbap/tree/main/docs/UML\%20Diagrams
\label{github-repo}

\section{Test Files for C\#}
https://github.com/IgorSteps/matbap/tree/main/app.Test
\section{Test Files for F\#}
https://github.com/IgorSteps/matbap/tree/main/engine.Test

\end{document}

